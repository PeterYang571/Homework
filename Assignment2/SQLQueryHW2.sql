---------------------------------Guidance---------------------------------------------------------------------------------------------
--First Part is Answer Questions and Last Two Parts using different Database to implement different Result Sets.
--Plz uncomment for the 'Use Database' & 'Go' for each part and then uncomment specfic queries for each question to execute and check the result set.

-------------------------Answer Folowing Quesitons-------------------------------------------------------------------------------------------------------
--1.What is a result set?
  --A Result set object is a table of data representing a database result set, which is usually generated by executing a statement that queries the database

--2.What is the difference between Union and Union All?
  --The only difference between Union and Union All is that Union extracts the rows that are being specified in the query 
  --while Union All extracts all the rows including the duplicates (repeated values) from both the queries

--3.What are the other Set Operators SQL Server has?
  --Set Operators in SQL Server (UNION, UNION ALL, INTERSECT, EXCEPT) SET operators are mainly used to combine the same type of data from two or more tables.

--4.What is the difference between Union and Join?
  --UNION combines the results of two or more queries into a single result set that includes all the rows that belong to all queries in the union
  --Using JOINs, you can retrieve data from two or more tables based on logical relationships between the tables. 
  --Joins indicate how SQL should use data from one table to select the rows in another table.

--5.What is the difference between INNER JOIN and FULL JOIN?
  --Inner join returns only the matching rows between both the tables, non-matching rows are eliminated. Full Join or Full Outer Join 
  --returns all rows from both the tables (left & right tables), including non-matching rows from both the tables.

--6.What is difference between left join and outer join
  --The main difference between the Left Join and Right Join lies in the inclusion of non-matched rows. Left outer join includes the unmatched rows from the table 
  --which is on the left of the join clause whereas a Right outer join includes the unmatched rows from the table which is on the right of the join clause.

--7.What is cross join?
  --A cross join is a type of join that returns the Cartesian product of rows from the tables in the join. In other words, 
  --it combines each row from the first table with each row from the second table.
  
--8.What is the difference between WHERE clause and HAVING clause? 
  --The main difference between them is that the WHERE clause is used to specify a condition for filtering records before any groupings are made, 
  --while the HAVING clause is used to specify a condition for filtering values from a group.

--9.Can there be multiple group by columns?
  --Yes, A GROUP BY clause can contain two or more columns—or, in other words, a grouping can consist of two or more columns


-------------------------Write queries for following scenarios----------------------------------------------------
-------------------------Using AdventureWorks2019 Database--------------------------------------------------------
Use AdventureWorks2019
Go

--#1
--Select Count(*) from Production.Product

--#2
--Select Count(ProductSubcategoryID) AS Subcategory 
--From Production.Product
--Where ProductSubcategoryID IS NOT NULL

--#3
--Select ProductSubcategoryID, Count(*) AS CountedProducts
--From Production.Product
--Group By ProductSubcategoryID

--#4
--Select Count(*) - Count(ProductSubcategoryID)
--From Production.Product

--#5
--Select ProductID, Sum(Quantity) AS TheSum 
--From Production.ProductInventory
--Group By ProductID

--#6
--Select ProductID, Sum(Quantity) AS TheSum
--From Production.ProductInventory
--Where LocationID = 40
--Group By ProductID
--Having Sum(Quantity) <100
--Order By TheSum

--#7
--Select Shelf, ProductID, Sum(Quantity) AS TheSum
--From Production.ProductInventory
--Where LocationID = 40
--Group By Shelf, ProductID
--Having Sum(Quantity) < 100
--Order By TheSum

--#8
--Select LocationID, AVG(Quantity) AS TheAvg
--From Production.ProductInventory
--Where LocationID = 10
--Group By LocationID

--#9
--Select ProductID, Shelf, Avg(Quantity) AS TheAvg
--From Production.ProductInventory
--Group By ProductID, Shelf

--#10
--Solution#1
--Select ProductID, isNULL (Shelf, 'N/A') AS Shelf, Avg(Quantity) AS TheAvg
--From Production.ProductInventory
--Group By ProductID, Shelf

--Solution#2
--Select ProductID, Shelf, Avg(Quantity) AS TheAvg
--From Production.ProductInventory
--Where Shelf <> 'N/A'
--Group By ProductID, Shelf

--#11
--Select Color, Class, Count(*) AS TheCount, AVG(ListPrice) AS AvgPrice
--From Production.Product
--Where Color IS NOT NULL AND Class IS NOT NULL
--GROUP BY GROUPING SETS ((Color), (Class))

--Joins:
--#12
--Select cr.Name AS Country, sp.Name AS Province 
--From Person.CountryRegion cr inner join Person.StateProvince sp
--On cr.CountryRegionCode = sp.CountryRegionCode

--#13
--Select cr.Name AS Country, sp.Name AS Province
--From Person.CountryRegion cr inner join Person.StateProvince sp
--on cr.CountryRegionCode = sp.CountryRegionCode
--Where cr.Name = 'Canada' OR cr.Name = 'Germany' --or Where cr.Name IN ('Germany', 'Canada')

--------------------------Using Northwind Database---------------------------------------------------------
Use Northwind
Go

--#14
--Select p.ProductName
--from Products p inner join [Order Details] od
--on p.ProductID = od.ProductID
--Where od.Quantity > 0

--#15
--Select Top 5 o.ShipPostalCode AS 'Zip Code'
--From [Order Details] od inner join Orders o
--on od.OrderID = o.OrderID
--Where ShipPostalCode IS NOT NULL
--Group By ShipPostalCode
--Order By Sum(od.Quantity) DESC

--#16
--select Top 5 o.ShipPostalCode AS 'Zip Code'
--From Orders o Inner Join [Order Details] od
--on o.OrderID = od.OrderID 
--where OrderDate > DATEADD(YEAR,-20,GETDATE())
--AND ShipPostalCode IS NOT NULL
--Group By ShipPostalCode
--Order By Sum(od.Quantity) DESC

--#17
--Select City, Count(1) AS NumOfCity
--From Customers c
--Group By City
--Order By NumOfCity ASC

--#18
--Select City, Count(1) AS NumOfCity
--From Customers c
--Group By City
--Having Count(1) > 10

--#19
--Select Distinct c.CompanyName AS CustomerName
--From Customers c Inner Join Orders o
--on c.CustomerID = o.CustomerId
--Where OrderDate > '1/1/98'

--#20
--Select c.CompanyName AS CustomerName, MAX(OrderDate) AS 'RecentOrderDate'
--From  Orders o Inner Join Customers c 
--on o.CustomerID = c.CustomerID
--Group By CompanyName

--#21
--Select c.CompanyName AS CustomerName, Sum(od.Quantity) AS NumberofBuy
--From [Order Details] od Inner Join Orders o  
--on od.OrderID = o.OrderID 
--inner join Customers c
--on o.CustomerID = c.CustomerID 
--Group By CompanyName

--#22
--Select o.CustomerID, Sum(od.Quantity) AS NumberofBuy
--From [Order Details] od Inner Join Orders o  
--on od.OrderID = o.OrderID 
--Group By CustomerID
--Having Sum(od.Quantity) > 100

--#23
--Select su.CompanyName 'Supplier Company Name', sh.CompanyName 'Shipping Company Name' 
--From Suppliers su Cross Join Shippers sh

--#24
--Select o.OrderDate, p.ProductName
--From Orders o Cross Join Products p

--#25
--select Distinct em1.EmployeeID as 'EmPair1' , em2.EmployeeID AS 'EmPair2'
--From Employees em1 Inner Join Employees em2
--on em1.Title=em2.Title
--where em1.EmployeeID <> em2.EmployeeID

--#26
--Select Distinct em1.LastName,em1.FirstName 
--From Employees em1 inner join Employees em2
--on em1.EmployeeID = em2.ReportsTo
--Group By em1.Lastname, em1.Firstname
--Having Count(em1.EmployeeID) > 2

--#27
--select city, ContactName from Customers
--union
--select city, contactname from Suppliers

----------------------------------------------------------
---Code for creating tables for #27 & #28--------------
/* Create a table called F1 */
--CREATE TABLE F1(F1T1 integer PRIMARY KEY);
--/* Create few records in this table */
--INSERT INTO F1 VALUES(1);
--INSERT INTO F1 VALUES(2);
--INSERT INTO F1 VALUES(3);

--/* Create a table called F2 */
--CREATE TABLE F2(F2T2 integer PRIMARY KEY);
--/* Create few records in this table */
--INSERT INTO F2 VALUES(2);
--INSERT INTO F2 VALUES(3);
--INSERT INTO F2 VALUES(4);

--#28 Inner Join
--Select * From F1 Inner Join F2 
--on F1.F1T1 = F2.F2T2
--Result 2|3
--       2|3

--#29 Left Outer Join
--Select * From F1 Left Outer Join F2
--on F1.F1T1= F2.F2T2
--Result 1|
--       2|2
--       3|3
